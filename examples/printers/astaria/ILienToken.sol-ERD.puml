@startuml examples/printers/astaria/ILienToken.sol

package IAstariaRouter {

    enum IAstariaRouter.FileType {
        FeeTo
        LiquidationFee
        ProtocolFee
        StrategistFee
        MinEpochLength
        MaxEpochLength
        MinInterestRate
        MaxInterestRate
        AuctionWindow
        StrategyValidator
        Implementation
        CollateralToken
        LienToken
        TransferProxy
    }

    enum IAstariaRouter.ImplementationType {
        PrivateVault
        PublicVault
        WithdrawProxy
        ClearingHouse
    }

    enum IAstariaRouter.LienRequestType {
        DEACTIVATED
        UNIQUE
        COLLECTION
        UNIV3_LIQUIDITY
    }

    enum IAstariaRouter.LienState {
        HEALTHY
        AUCTION
    }

    enum IAstariaRouter.CollateralStates {
        AUCTION
        NO_AUCTION
        NO_DEPOSIT
        NO_LIENS
    }

    enum IAstariaRouter.CommitmentState {
        INVALID
        INVALID_RATE
        INVALID_AMOUNT
        COLLATERAL_AUCTION
        COLLATERAL_NO_DEPOSIT
    }

    enum IAstariaRouter.VaultState {
        UNINITIALIZED
        CORRUPTED
        CLOSED
        LIQUIDATED
    }

    struct IAstariaRouter.File {
        {field}IAstariaRouter.FileType what
        {field}bytes data
    }

    struct IAstariaRouter.RouterStorage {
        {field}uint32 auctionWindow
        {field}uint32 liquidationFeeNumerator
        {field}uint32 liquidationFeeDenominator
        {field}uint32 maxEpochLength
        {field}uint32 minEpochLength
        {field}uint32 protocolFeeNumerator
        {field}uint32 protocolFeeDenominator
        {field}ICollateralToken(address) COLLATERAL_TOKEN
        {field}ILienToken(address) LIEN_TOKEN
        {field}ITransferProxy(address) TRANSFER_PROXY
        {field}address feeTo
        {field}address BEACON_PROXY_IMPLEMENTATION
        {field}uint256 maxInterestRate
        {field}address guardian
        {field}address newGuardian
        {field}mapping(uint8 => address) strategyValidators
        {field}mapping(uint8 => address) implementations
        {field}mapping(address => bool) vaults
    }

    struct IAstariaRouter.StrategyDetailsParam {
        {field}uint8 version
        {field}uint256 deadline
        {field}address vault
    }

    struct IAstariaRouter.MerkleData {
        {field}bytes32 root
        {field}bytes32[] proof
    }

    struct IAstariaRouter.NewLienRequest {
        {field}IAstariaRouter.StrategyDetailsParam strategy
        {field}ILienToken.Stack[] stack
        {field}bytes nlrDetails
        {field}IAstariaRouter.MerkleData merkle
        {field}uint256 amount
        {field}uint8 v
        {field}bytes32 r
        {field}bytes32 s
    }

    struct IAstariaRouter.Commitment {
        {field}address tokenContract
        {field}uint256 tokenId
        {field}IAstariaRouter.NewLienRequest lienRequest
    }

}

package IClearingHouse {

    struct IClearingHouse.AuctionStack {
        {field}uint256 lienId
        {field}uint256 amountOwed
        {field}uint40 end
    }

    struct IClearingHouse.AuctionData {
        {field}uint256 startAmount
        {field}uint256 endAmount
        {field}uint48 startTime
        {field}uint48 endTime
        {field}address liquidator
        {field}address token
        {field}IClearingHouse.AuctionStack[] stack
    }

    struct IClearingHouse.ClearingHouseStorage {
        {field}IClearingHouse.AuctionData auctionData
    }

}

package ConsiderationInterface {

}

package ConduitControllerInterface {

}

package ICollateralToken {

    enum ICollateralToken.FileType {
        NotSupported
        AstariaRouter
        SecurityHook
        FlashEnabled
        Seaport
    }

    enum ICollateralToken.InvalidCollateralStates {
        NO_AUTHORITY
        NO_AUCTION
        FLASH_DISABLED
        AUCTION_ACTIVE
        INVALID_AUCTION_PARAMS
        ACTIVE_LIENS
    }

    struct ICollateralToken.Asset {
        {field}bool deposited
        {field}address clearingHouse
        {field}address tokenContract
        {field}uint256 tokenId
        {field}bytes32 auctionHash
    }

    struct ICollateralToken.CollateralStorage {
        {field}ITransferProxy(address) TRANSFER_PROXY
        {field}ILienToken(address) LIEN_TOKEN
        {field}IAstariaRouter(address) ASTARIA_ROUTER
        {field}ConsiderationInterface(address) SEAPORT
        {field}ConduitControllerInterface(address) CONDUIT_CONTROLLER
        {field}address CONDUIT
        {field}bytes32 CONDUIT_KEY
        {field}mapping(uint256 => bytes32) collateralIdToAuction
        {field}mapping(address => bool) flashEnabled
        {field}mapping(uint256 => ICollateralToken.Asset) idToUnderlying
        {field}mapping(address => address) securityHooks
    }

    struct ICollateralToken.ListUnderlyingForSaleParams {
        {field}ILienToken.Stack[] stack
        {field}uint256 listPrice
        {field}uint56 maxDuration
    }

    struct ICollateralToken.File {
        {field}ICollateralToken.FileType what
        {field}bytes data
    }

    struct ICollateralToken.AuctionVaultParams {
        {field}address settlementToken
        {field}uint256 collateralId
        {field}uint256 maxDuration
        {field}uint256 startingPrice
        {field}uint256 endingPrice
    }

}

package ILienToken {

    enum ILienToken.FileType {
        NotSupported
        CollateralToken
        AstariaRouter
        BuyoutFee
        BuyoutFeeDurationCap
        MinInterestBPS
        MinDurationIncrease
    }

    enum ILienToken.StackAction {
        CLEAR
        ADD
        REMOVE
        REPLACE
    }

    enum ILienToken.InvalidStates {
        NO_AUTHORITY
        COLLATERAL_MISMATCH
        ASSET_MISMATCH
        NOT_ENOUGH_FUNDS
        INVALID_LIEN_ID
        COLLATERAL_AUCTION
        COLLATERAL_NOT_DEPOSITED
        LIEN_NO_DEBT
        EXPIRED_LIEN
        DEBT_LIMIT
        MAX_LIENS
        INVALID_HASH
        INVALID_LIQUIDATION_INITIAL_ASK
        INITIAL_ASK_EXCEEDED
        EMPTY_STATE
        PUBLIC_VAULT_RECIPIENT
        COLLATERAL_NOT_LIQUIDATED
    }

    struct ILienToken.File {
        {field}ILienToken.FileType what
        {field}bytes data
    }

    struct ILienToken.LienStorage {
        {field}uint8 maxLiens
        {field}ITransferProxy(address) TRANSFER_PROXY
        {field}IAstariaRouter(address) ASTARIA_ROUTER
        {field}ICollateralToken(address) COLLATERAL_TOKEN
        {field}mapping(uint256 => bytes32) collateralStateHash
        {field}mapping(uint256 => ILienToken.LienMeta) lienMeta
        {field}uint32 buyoutFeeNumerator
        {field}uint32 buyoutFeeDenominator
        {field}uint32 durationFeeCapNumerator
        {field}uint32 durationFeeCapDenominator
        {field}uint32 minDurationIncrease
        {field}uint32 minInterestBPS
    }

    struct ILienToken.LienMeta {
        {field}address payee
        {field}bool atLiquidation
    }

    struct ILienToken.Details {
        {field}uint256 maxAmount
        {field}uint256 rate
        {field}uint256 duration
        {field}uint256 maxPotentialDebt
        {field}uint256 liquidationInitialAsk
    }

    struct ILienToken.Lien {
        {field}uint8 collateralType
        {field}address token
        {field}address vault
        {field}bytes32 strategyRoot
        {field}uint256 collateralId
        {field}ILienToken.Details details
    }

    struct ILienToken.Point {
        {field}uint256 amount
        {field}uint40 last
        {field}uint40 end
        {field}uint256 lienId
    }

    struct ILienToken.Stack {
        {field}ILienToken.Lien lien
        {field}ILienToken.Point point
    }

    struct ILienToken.LienActionEncumber {
        {field}uint256 amount
        {field}address receiver
        {field}ILienToken.Lien lien
        {field}ILienToken.Stack[] stack
    }

    struct ILienToken.LienActionBuyout {
        {field}bool chargeable
        {field}uint8 position
        {field}ILienToken.LienActionEncumber encumber
    }

    struct ILienToken.BuyoutLienParams {
        {field}uint256 lienSlope
        {field}uint256 lienEnd
    }

}

package ITransferProxy {

}

IAstariaRouter.File::what --> IAstariaRouter.FileType
ICollateralToken.ListUnderlyingForSaleParams::stack --> ILienToken.Stack
ICollateralToken.File::what --> ICollateralToken.FileType
ILienToken.LienActionEncumber::lien --> ILienToken.Lien
ILienToken.LienActionBuyout::encumber --> ILienToken.LienActionEncumber
IClearingHouse.ClearingHouseStorage::auctionData --> IClearingHouse.AuctionData
ILienToken.Lien::details --> ILienToken.Details
IClearingHouse.AuctionData::stack --> IClearingHouse.AuctionStack
IAstariaRouter.NewLienRequest::strategy --> IAstariaRouter.StrategyDetailsParam
ILienToken.LienActionEncumber::stack --> ILienToken.Stack
ILienToken.Stack::lien --> ILienToken.Lien
IAstariaRouter.Commitment::lienRequest --> IAstariaRouter.NewLienRequest
IAstariaRouter.NewLienRequest::merkle --> IAstariaRouter.MerkleData
ICollateralToken.CollateralStorage::idToUnderlying --> ICollateralToken.Asset
IAstariaRouter.NewLienRequest::stack --> ILienToken.Stack
ILienToken.LienStorage::lienMeta --> ILienToken.LienMeta
ILienToken.File::what --> ILienToken.FileType
ILienToken.Stack::point --> ILienToken.Point

@enduml